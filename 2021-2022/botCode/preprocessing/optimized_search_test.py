from directions import STOP
import lookup_tables  # preprocessed grid (meta)data

from optimized_search import get_dist_and_dir




from collections import deque
def makePathList(node, previousNodes):
    path = []
    while previousNodes[node] is not None:
        path.append(node)
        node = previousNodes[node]
    return path or None
neighbors = {(1,1):((2,1),(1,2)),(1,2):((1,3),(1,1)),(1,3):((1,4),(1,2)),(1,4):((2,4),(1,3)),(1,7):((2,7),(1,8)),(1,8):((1,9),(1,7)),(1,9):((1,10),(1,8)),(1,10):((2,10),(1,9)),(1,22):((2,22),(1,23)),(1,23):((1,24),(1,22)),(1,24):((1,25),(1,23)),(1,25):((2,25),(1,26),(1,24)),(1,26):((1,27),(1,25)),(1,27):((1,28),(1,26)),(1,28):((1,29),(1,27)),(1,29):((2,29),(1,28)),(2,1):((3,1),(1,1)),(2,4):((3,4),(1,4)),(2,7):((3,7),(1,7)),(2,10):((3,10),(1,10)),(2,22):((3,22),(1,22)),(2,25):((3,25),(1,25)),(2,29):((3,29),(1,29)),(3,1):((4,1),(2,1)),(3,4):((4,4),(2,4),(3,5)),(3,5):((3,6),(3,4)),(3,6):((3,7),(3,5)),(3,7):((2,7),(3,6)),(3,10):((4,10),(2,10)),(3,22):((4,22),(2,22)),(3,25):((4,25),(2,25)),(3,29):((4,29),(2,29)),(4,1):((5,1),(3,1)),(4,4):((5,4),(3,4)),(4,10):((5,10),(3,10)),(4,22):((5,22),(3,22)),(4,25):((5,25),(3,25)),(4,29):((5,29),(3,29)),(5,1):((6,1),(4,1)),(5,4):((6,4),(4,4)),(5,10):((6,10),(4,10)),(5,22):((6,22),(4,22)),(5,25):((6,25),(4,25)),(5,29):((6,29),(4,29)),(6,1):((7,1),(5,1)),(6,4):((5,4),(6,5)),(6,5):((6,6),(6,4)),(6,6):((6,7),(6,5)),(6,7):((7,7),(6,8),(6,6)),(6,8):((6,9),(6,7)),(6,9):((6,10),(6,8)),(6,10):((7,10),(5,10),(6,11),(6,9)),(6,11):((6,12),(6,10)),(6,12):((6,13),(6,11)),(6,13):((6,14),(6,12)),(6,14):((6,15),(6,13)),(6,15):((6,16),(6,14)),(6,16):((7,16),(6,17),(6,15)),(6,17):((6,18),(6,16)),(6,18):((6,19),(6,17)),(6,19):((6,20),(6,18)),(6,20):((6,21),(6,19)),(6,21):((6,22),(6,20)),(6,22):((5,22),(6,23),(6,21)),(6,23):((6,24),(6,22)),(6,24):((6,25),(6,23)),(6,25):((7,25),(5,25),(6,26),(6,24)),(6,26):((6,27),(6,25)),(6,27):((6,28),(6,26)),(6,28):((6,29),(6,27)),(6,29):((7,29),(5,29),(6,28)),(7,1):((8,1),(6,1)),(7,7):((8,7),(6,7)),(7,10):((8,10),(6,10)),(7,16):((8,16),(6,16)),(7,25):((8,25),(6,25)),(7,29):((8,29),(6,29)),(8,1):((9,1),(7,1)),(8,7):((9,7),(7,7)),(8,10):((9,10),(7,10)),(8,16):((9,16),(7,16)),(8,25):((9,25),(7,25)),(8,29):((9,29),(7,29)),(9,1):((10,1),(8,1)),(9,4):((10,4),(9,5)),(9,5):((9,6),(9,4)),(9,6):((9,7),(9,5)),(9,7):((10,7),(8,7),(9,6)),(9,10):((10,10),(8,10),(9,11)),(9,11):((9,12),(9,10)),(9,12):((9,13),(9,11)),(9,13):((10,13),(9,14),(9,12)),(9,14):((9,15),(9,13)),(9,15):((9,16),(9,14)),(9,16):((8,16),(9,17),(9,15)),(9,17):((9,18),(9,16)),(9,18):((9,19),(9,17)),(9,19):((10,19),(9,18)),(9,22):((10,22),(9,23)),(9,23):((9,24),(9,22)),(9,24):((9,25),(9,23)),(9,25):((10,25),(8,25),(9,24)),(9,29):((10,29),(8,29)),(10,1):((11,1),(9,1)),(10,4):((11,4),(9,4)),(10,7):((11,7),(9,7)),(10,10):((11,10),(9,10)),(10,13):((11,13),(9,13)),(10,19):((11,19),(9,19)),(10,22):((11,22),(9,22)),(10,25):((11,25),(9,25)),(10,29):((11,29),(9,29)),(11,1):((12,1),(10,1)),(11,4):((12,4),(10,4)),(11,7):((12,7),(10,7)),(11,10):((12,10),(10,10)),(11,13):((12,13),(10,13)),(11,19):((12,19),(10,19)),(11,22):((12,22),(10,22)),(11,25):((12,25),(10,25)),(11,29):((12,29),(10,29)),(12,1):((13,1),(11,1),(12,2)),(12,2):((12,3),(12,1)),(12,3):((12,4),(12,2)),(12,4):((11,4),(12,3)),(12,7):((13,7),(11,7),(12,8)),(12,8):((12,9),(12,7)),(12,9):((12,10),(12,8)),(12,10):((11,10),(12,9)),(12,13):((13,13),(11,13)),(12,19):((13,19),(11,19),(12,20)),(12,20):((12,21),(12,19)),(12,21):((12,22),(12,20)),(12,22):((11,22),(12,21)),(12,25):((13,25),(11,25),(12,26)),(12,26):((12,27),(12,25)),(12,27):((12,28),(12,26)),(12,28):((12,29),(12,27)),(12,29):((11,29),(12,28)),(13,1):((14,1),(12,1)),(13,7):((14,7),(12,7)),(13,13):((14,13),(12,13)),(13,19):((14,19),(12,19)),(13,25):((14,25),(12,25)),(14,1):((15,1),(13,1)),(14,7):((15,7),(13,7)),(14,13):((15,13),(13,13)),(14,19):((15,19),(13,19)),(14,25):((15,25),(13,25)),(15,1):((16,1),(14,1),(15,2)),(15,2):((15,3),(15,1)),(15,3):((15,4),(15,2)),(15,4):((16,4),(15,3)),(15,7):((16,7),(14,7),(15,8)),(15,8):((15,9),(15,7)),(15,9):((15,10),(15,8)),(15,10):((16,10),(15,9)),(15,13):((16,13),(14,13)),(15,19):((16,19),(14,19),(15,20)),(15,20):((15,21),(15,19)),(15,21):((15,22),(15,20)),(15,22):((16,22),(15,21)),(15,25):((16,25),(14,25),(15,26)),(15,26):((15,27),(15,25)),(15,27):((15,28),(15,26)),(15,28):((15,29),(15,27)),(15,29):((16,29),(15,28)),(16,1):((17,1),(15,1)),(16,4):((17,4),(15,4)),(16,7):((17,7),(15,7)),(16,10):((17,10),(15,10)),(16,13):((17,13),(15,13)),(16,19):((17,19),(15,19)),(16,22):((17,22),(15,22)),(16,25):((17,25),(15,25)),(16,29):((17,29),(15,29)),(17,1):((18,1),(16,1)),(17,4):((18,4),(16,4)),(17,7):((18,7),(16,7)),(17,10):((18,10),(16,10)),(17,13):((18,13),(16,13)),(17,19):((18,19),(16,19)),(17,22):((18,22),(16,22)),(17,25):((18,25),(16,25)),(17,29):((18,29),(16,29)),(18,1):((19,1),(17,1)),(18,4):((17,4),(18,5)),(18,5):((18,6),(18,4)),(18,6):((18,7),(18,5)),(18,7):((19,7),(17,7),(18,6)),(18,10):((19,10),(17,10),(18,11)),(18,11):((18,12),(18,10)),(18,12):((18,13),(18,11)),(18,13):((17,13),(18,14),(18,12)),(18,14):((18,15),(18,13)),(18,15):((18,16),(18,14)),(18,16):((19,16),(18,17),(18,15)),(18,17):((18,18),(18,16)),(18,18):((18,19),(18,17)),(18,19):((17,19),(18,18)),(18,22):((17,22),(18,23)),(18,23):((18,24),(18,22)),(18,24):((18,25),(18,23)),(18,25):((19,25),(17,25),(18,24)),(18,29):((19,29),(17,29)),(19,1):((20,1),(18,1)),(19,7):((20,7),(18,7)),(19,10):((20,10),(18,10)),(19,16):((20,16),(18,16)),(19,25):((20,25),(18,25)),(19,29):((20,29),(18,29)),(20,1):((21,1),(19,1)),(20,7):((21,7),(19,7)),(20,10):((21,10),(19,10)),(20,16):((21,16),(19,16)),(20,25):((21,25),(19,25)),(20,29):((21,29),(19,29)),(21,1):((22,1),(20,1)),(21,4):((22,4),(21,5)),(21,5):((21,6),(21,4)),(21,6):((21,7),(21,5)),(21,7):((20,7),(21,8),(21,6)),(21,8):((21,9),(21,7)),(21,9):((21,10),(21,8)),(21,10):((22,10),(20,10),(21,11),(21,9)),(21,11):((21,12),(21,10)),(21,12):((21,13),(21,11)),(21,13):((21,14),(21,12)),(21,14):((21,15),(21,13)),(21,15):((21,16),(21,14)),(21,16):((20,16),(21,17),(21,15)),(21,17):((21,18),(21,16)),(21,18):((21,19),(21,17)),(21,19):((21,20),(21,18)),(21,20):((21,21),(21,19)),(21,21):((21,22),(21,20)),(21,22):((22,22),(21,23),(21,21)),(21,23):((21,24),(21,22)),(21,24):((21,25),(21,23)),(21,25):((22,25),(20,25),(21,26),(21,24)),(21,26):((21,27),(21,25)),(21,27):((21,28),(21,26)),(21,28):((21,29),(21,27)),(21,29):((22,29),(20,29),(21,28)),(22,1):((23,1),(21,1)),(22,4):((23,4),(21,4)),(22,10):((23,10),(21,10)),(22,22):((23,22),(21,22)),(22,25):((23,25),(21,25)),(22,29):((23,29),(21,29)),(23,1):((24,1),(22,1)),(23,4):((24,4),(22,4)),(23,10):((24,10),(22,10)),(23,22):((24,22),(22,22)),(23,25):((24,25),(22,25)),(23,29):((24,29),(22,29)),(24,1):((25,1),(23,1)),(24,4):((25,4),(23,4),(24,5)),(24,5):((24,6),(24,4)),(24,6):((24,7),(24,5)),(24,7):((25,7),(24,6)),(24,10):((25,10),(23,10)),(24,22):((25,22),(23,22)),(24,25):((25,25),(23,25)),(24,29):((25,29),(23,29)),(25,1):((26,1),(24,1)),(25,4):((26,4),(24,4)),(25,7):((26,7),(24,7)),(25,10):((26,10),(24,10)),(25,22):((26,22),(24,22)),(25,25):((26,25),(24,25)),(25,29):((26,29),(24,29)),(26,1):((25,1),(26,2)),(26,2):((26,3),(26,1)),(26,3):((26,4),(26,2)),(26,4):((25,4),(26,3)),(26,7):((25,7),(26,8)),(26,8):((26,9),(26,7)),(26,9):((26,10),(26,8)),(26,10):((25,10),(26,9)),(26,22):((25,22),(26,23)),(26,23):((26,24),(26,22)),(26,24):((26,25),(26,23)),(26,25):((25,25),(26,26),(26,24)),(26,26):((26,27),(26,25)),(26,27):((26,28),(26,26)),(26,28):((26,29),(26,27)),(26,29):((25,29),(26,28))}
def breadth_first_search(start, goal):
    nodeQueue = deque()
    nodeQueue.append(start)
    visited = {start: None}
    
    visit_count = 0
    try:
        while nodeQueue:
            current = nodeQueue.popleft()
            visit_count += 1
            #Stops and returns the best path
            if current == goal:
                return makePathList(current, visited)
            
            #Looks for paths
            for n in neighbors[current]:
                if n not in visited:
                    nodeQueue.append(n)
                    visited[n] = current
    finally:
        pass #print(f'BFS visited {visit_count} nodes')
    return None

def get_dist_and_dir_bad(start, goal):
    if start == goal:
        return 0, STOP
    from directions import get_direction
    path = breadth_first_search(start, goal)
    if path is None:
        return None
    return len(path), get_direction(start, path[-1])


import random
def get_rand_loc():
    return random.choice(list(lookup_tables.tile_table.keys()))

# import timeit
# num = 10000 * 20 * 6
# print(len(lookup_tables.tile_table)**2)
# random.seed("foo")
# bad = timeit.timeit(f'get_dist_and_dir_bad(start, goal)', setup='start,goal=get_rand_loc(),get_rand_loc()', globals=globals(), number=num)/num*1000
# random.seed("foo")
# good = timeit.timeit(f'get_dist_and_dir(start, goal)', setup='start,goal=get_rand_loc(),get_rand_loc()', globals=globals(), number=1*num)/(1*num)*1000
# print("bad: ", bad, 'ms')
# print("good:", good, 'ms')
# print(bad/good)
# exit(0)

keep_going = True
max_path_len = -1
def test(start, goal):
    import timeit
    # print("bad: ", timeit.timeit(f'get_dist_and_dir_bad({start}, {goal})', globals=globals(), number=10000)/10000*1000, 'ms')
    # print("good:", timeit.timeit(f'get_dist_and_dir({start}, {goal})', globals=globals(), number=1000000)/1000000*1000, 'ms')
    print(start, goal)
    res1 = get_dist_and_dir_bad(start, goal)
    res2 = get_dist_and_dir(start, goal)
    
    global max_path_len
    if res1[0] > max_path_len:
        max_path_len = res1[0]
    
    if res1 == res2:
        print('GOOD!')
    else:
        print('BAD!!!!!!!!')
        global keep_going
        keep_going = False
        
        from directions import move_direction
        start2 = move_direction(start, res2[1])
        res1_again = get_dist_and_dir_bad(start2, goal)
        if res1_again[0]+1 == res2[0]:
            print("but actually good")
            keep_going = True
        
        from wall_grid import wall_grid
        r_range = range(len(wall_grid))
        c_range = range(len(wall_grid[0]))
        for r in r_range:
            row_str = ''
            for c in c_range:
                loc = (r, c)
                if loc == start:
                    row_str += 'ss'
                elif loc == goal:
                    row_str += 'gg'
                elif wall_grid[r][c]:
                    row_str += '  '
                else:
                    row_str += '[]'
            print(row_str)
    print('   ', res1)
    print('   ', res2)
    print()

start = (5, 1)
goal = (21, 14)

import itertools
# for _ in range(10):
for start, goal in itertools.product(lookup_tables.tile_table.keys(), lookup_tables.tile_table.keys()):
    test(start, goal)
    if not keep_going:
        break
print("finished all successfully:", keep_going)
print("max path length:", max_path_len)

"""
Ultimately, I need:
 - distance & direction to go from one intersection to another
 - for any walkable tile:
    - if it's an intersection, its ID
    - otherwise, for each of the two adjacent intersections:
        - the intersection ID
        - the distance & direction to the intersection

Different input cases:
 - start & goal are both intersection tiles
    - default algorithm will always work
 - start is a segment tile, goal is an intersection tile
    - default algorithm will always work
 - start is an intersection tile, goal is a segment tile
    - if start is one of the intersections adjacent to goal's segment:
        - distance is goal's distance to the intersection
        - direction is the intersection's direction to the adjacent intersection
    - else: default algorithm will work
 - start & goal are both segment tiles
    - if start & goal are in the same segment:
        - distance is ...TODO
        - direction is ...TODO
    - else: default algorithm will work

 - start & goal are segment tiles in the same segment
 - start is one of the intersections of goal's segment
"""